// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/security/Pausable.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";

contract BlueBirdX is ERC20, Ownable, ReentrancyGuard, Pausable {
    using SafeMath for uint256;

    address public developmentFund;
    address public liquidityPool;
    address public teamAdvisors;
    uint256 public miningRate;
    uint256 public currentMiningRate = 100;
    uint256 public liquidityPoolRate = 10;
    uint256 public developmentFundRate = 7;
    uint256 public teamAdvisorsRate = 3;
    uint256 public deploymentTime;
    uint256 public constant MAX_SUPPLY = 5_000_000_000 * 10**18;
    uint256 public totalMinedSupply;
    uint256 public remainingSupply = MAX_SUPPLY;
    uint256 public constant SUPPLY_REDUCTION_PERCENTAGE = 20;
    uint256 public constant MAX_ALLOWED_BALANCE_PERCENTAGE = 50; // 0.5%
    uint256 public constant TRANSFER_LIMIT = 10; // 0.1% of total BBX supply
    uint256 public transferFeeRate = 1; // 0.1% of the amount
    uint256 public developmentFundFeeRate = 1; // 0.01% of the amount

    mapping(address => bool) public isExcludedFromMaxBalance;
    mapping(address => bool) public isExcludedFromTransferFee;
    mapping(address => uint256) private lastRewardClaim;
    mapping(address => bool) private blacklistedAddresses;
    mapping(address => bool) private hasMovedTokens;

    struct Allocation {
        uint256 amount;
        uint256 claimed;
        uint256 lastClaim;
    }

    mapping(address => Allocation) public teamAdvisorAllocations;

    event RewardClaimed(address indexed user, uint256 amount);
    event TokenTransferred(address indexed sender, address indexed recipient, uint256 amount);
    event TokenTransacted(address indexed sender, address indexed recipient, uint256 tokenAmount, uint256 rewardAmount);
    event TeamAdvisorDistributionClaimed(address indexed teamAdvisor, uint256 amount);

    uint256 public constant INITIAL_LOCK_PERIOD = 365 days;
    uint256 public constant QUARTER = 91 days;

    mapping(address => bool) public eligibleTokens;
    mapping(address => uint256) public tokenMiningRates;
    address[] public eligibleTokenAddresses; // array to keep track of eligible tokens

    constructor(
        address _developmentFund,
        address _liquidityPool,
        address _teamAdvisors
    ) ERC20("BlueBirdX", "BBX") {
        require(_developmentFund != address(0), "Development fund address cannot be zero address");
        require(_liquidityPool != address(0), "Liquidity pool address cannot be zero address");
        require(_teamAdvisors != address(0), "Team advisors address cannot be zero address");

        developmentFund = _developmentFund;
        liquidityPool = _liquidityPool;
        teamAdvisors = _teamAdvisors;
        miningRate = 1;
        deploymentTime = block.timestamp;

        // Exclude development fund, liquidity pool, and team advisor wallets from the maximum allowed balance
        isExcludedFromMaxBalance[developmentFund] = true;
        isExcludedFromMaxBalance[liquidityPool] = true;
        isExcludedFromMaxBalance[teamAdvisors] = true;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal override {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");
        require(amount > 0, "Transfer amount must be greater than zero");
        require(!blacklistedAddresses[sender], "Sender is blacklisted from transferring tokens");
        require(!blacklistedAddresses[recipient], "Recipient is blacklisted from receiving tokens");

        uint256 maxAllowedBalance = (MAX_SUPPLY * MAX_ALLOWED_BALANCE_PERCENTAGE) / 10000;
        if (!isExcludedFromMaxBalance[recipient]) {
            require(
                balanceOf(recipient) + amount <= maxAllowedBalance,
                "Recipient's balance exceeds the maximum allowed"
            );
        }

        // Calculate the transfer fee
        uint256 transferFee = calculateTransferFee(amount);

        // Update balances
        super._transfer(sender, recipient, amount - transferFee);

        emit TokenTransferred(sender, recipient, amount - transferFee);
        emit TokenTransferred(sender, liquidityPool, transferFee);

        // Update the hasMovedTokens flag for the sender
        hasMovedTokens[sender] = true;
    }

    function calculateTransferFee(uint256 amount) private pure returns (uint256) {
        if (amount <= 100000) {
            return 0;
        } else if (amount <= 500000) {
            return (amount * 5) / 1000; // 0.5% of the amount
        } else if (amount <= 1000000) {
            return (amount * 75) / 10000; // 0.75% of the amount
        } else if (amount <= 2500000) {
            return (amount * 25) / 1000; // 2.5% of the amount
        } else {
            return (amount * 5) / 100; // 5% of the amount
        }
    }

    function addEligibleToken(address tokenAddress, uint256 newMiningRate) public onlyOwner {
        require(tokenAddress != address(0), "Token address cannot be zero address");
        require(!eligibleTokens[tokenAddress], "Token is already eligible for mining rewards");

        eligibleTokens[tokenAddress] = true;
        tokenMiningRates[tokenAddress] = newMiningRate;
        eligibleTokenAddresses.push(tokenAddress);
    }

    function removeEligibleToken(address tokenAddress) external onlyOwner {
        require(eligibleTokens[tokenAddress], "Token is not eligible for mining rewards");
        eligibleTokens[tokenAddress] = false;
        // Remove token from the list of eligible tokens
        for (uint256 i = 0; i < eligibleTokenAddresses.length; i++) {
            if (eligibleTokenAddresses[i] == tokenAddress) {
                eligibleTokenAddresses[i] = eligibleTokenAddresses[eligibleTokenAddresses.length - 1];
                eligibleTokenAddresses.pop();
                break;
            }
        }
    }

    function transactTokens(address tokenAddress, uint256 amount, address recipient) external nonReentrant {
        require(eligibleTokens[tokenAddress], "Token is not eligible for mining rewards");
        require(!blacklistedAddresses[msg.sender], "Sender is blacklisted from transacting tokens");

        // Calculate the transfer fee based on the tiered fee structure
        uint256 transferFee = calculateTransferFee(amount);
        uint256 transferAmount = amount - transferFee;

        // Ensure the sender has enough balance to cover the amount and the fees
        require(
            IERC20(tokenAddress).balanceOf(msg.sender) >= amount,
            "Insufficient balance to cover amount and fees"
        );

        // Transfer the amount minus the fees from the sender to the recipient
        IERC20(tokenAddress).transferFrom(msg.sender, recipient, transferAmount);

        // Transfer the fees from the sender to the liquidity pool
        IERC20(tokenAddress).transferFrom(msg.sender, liquidityPool, transferFee);

        // Calculate the reward based on the mining rate
        uint256 rewardAmount = (amount * currentMiningRate) / 10000;

        // Ensure the reward does not exceed the remaining supply
        require(remainingSupply >= rewardAmount, "Not enough remaining supply for reward");

        // Update the total mined supply and the remaining supply
        totalMinedSupply += rewardAmount;
        remainingSupply -= rewardAmount;

        // Check if the total mined supply has reached a 10% milestone of the remaining supply
        if (totalMinedSupply >= remainingSupply / 10) {
            // Reduce the mining rate by 25%
            currentMiningRate = (currentMiningRate * 75) / 100;
        }

        // Mint the reward tokens for the sender
        _mint(msg.sender, rewardAmount);

        // Mint the remaining reward tokens to the project wallets
        _mint(liquidityPool, rewardAmount * liquidityPoolRate / 100);
        _mint(developmentFund, rewardAmount * developmentFundRate / 100);
        _mint(teamAdvisors, rewardAmount * teamAdvisorsRate / 100);

        emit RewardClaimed(msg.sender, rewardAmount);
        emit TokenTransferred(msg.sender, recipient, transferAmount);
        emit TokenTransferred(msg.sender, liquidityPool, transferFee);

        // Update the hasMovedTokens flag for the sender
        hasMovedTokens[msg.sender] = true;
    }

    function claimTeamAdvisorDistribution() external nonReentrant {
        Allocation storage allocation = teamAdvisorAllocations[msg.sender];
        require(allocation.amount > 0, "No allocation for this address");
        require(block.timestamp >= allocation.lastClaim + QUARTER, "Claim period has not passed yet");

        uint256 claimableAmount = (allocation.amount * 25) / 100; // 25% of the allocation
        require(claimableAmount > 0, "No claimable amount");

        // Update the claimed amount and the last claim time
        allocation.claimed += claimableAmount;
        allocation.lastClaim = block.timestamp;

        // Mint the claimable tokens for the team advisor
        _mint(msg.sender, claimableAmount);

        emit TeamAdvisorDistributionClaimed(msg.sender, claimableAmount);
    }

    function claimReward() public nonReentrant {
        require(block.timestamp > lastRewardClaim[msg.sender] + 1 days, "Claim is only possible once every 24 hours");
        require(balanceOf(msg.sender) > 0, "No tokens to claim rewards for");
        require(!blacklistedAddresses[msg.sender], "Address is blacklisted from claiming rewards");
        require(!hasMovedTokens[msg.sender], "User has moved tokens and is disqualified from claiming rewards");

        uint256 reward = balanceOf(msg.sender) / 1000; // 0.1% of the token balance
        require(remainingSupply >= reward, "Not enough remaining supply for reward");

        // Update the total mined supply and the remaining supply
        totalMinedSupply += reward;
        remainingSupply -= reward;

        // Update the last claim time
        lastRewardClaim[msg.sender] = block.timestamp;

        // Mint the reward tokens for the sender
        _mint(msg.sender, reward);

        emit RewardClaimed(msg.sender, reward);
    }

    function blacklistAddress(address account) public onlyOwner {
        require(account != address(0), "Cannot blacklist zero address");
        require(!blacklistedAddresses[account], "Address is already blacklisted");

        blacklistedAddresses[account] = true;
    }

    function removeAddressFromBlacklist(address account) public onlyOwner {
        require(account != address(0), "Cannot remove zero address from blacklist");
        require(blacklistedAddresses[account], "Address is not blacklisted");

        blacklistedAddresses[account] = false;
    }

    function setTransferFeeRate(uint256 newTransferFeeRate) external onlyOwner {
        transferFeeRate = newTransferFeeRate;
    }

    function setDevelopmentFundFeeRate(uint256 newDevelopmentFundFeeRate) external onlyOwner {
        developmentFundFeeRate = newDevelopmentFundFeeRate;
    }

    function setLiquidityPoolRate(uint256 newLiquidityPoolRate) external onlyOwner {
        liquidityPoolRate = newLiquidityPoolRate;
    }

    function setDevelopmentFundRate(uint256 newDevelopmentFundRate) external onlyOwner {
        developmentFundRate = newDevelopmentFundRate;
    }

    function setTeamAdvisorsRate(uint256 newTeamAdvisorsRate) external onlyOwner {
        teamAdvisorsRate = newTeamAdvisorsRate;
    }

    function setMiningRate(uint256 newMiningRate) external onlyOwner {
        miningRate = newMiningRate;
    }
    function setTokenMiningRate(address tokenAddress, uint256 newMiningRate) external onlyOwner {
        require(eligibleTokens[tokenAddress], "Token is not eligible for mining rewards");
        tokenMiningRates[tokenAddress] = newMiningRate;
    }

    function excludeFromMaxBalance(address account) external onlyOwner {
        isExcludedFromMaxBalance[account] = true;
    }

    function includeInMaxBalance(address account) external onlyOwner {
        isExcludedFromMaxBalance[account] = false;
    }

    function excludeFromTransferFee(address account) external onlyOwner {
        isExcludedFromTransferFee[account] = true;
    }

    function includeInTransferFee(address account) external onlyOwner {
        isExcludedFromTransferFee[account] = false;
    }

    function emergencyPause() external onlyOwner {
        _pause();
    }

    function emergencyUnpause() external onlyOwner {
        _unpause();
    }
}

