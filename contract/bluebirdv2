// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract Bluetester is ERC20 {

    IERC20  public wsgbToken;
    address public developmentFund;
    address public liquidityPool;
    uint256 public miningRate;
    uint256 public currentMiningRate = 50;
    uint256 public liquidityPoolRate = 1000;
    uint256 public developmentFundRate = 100;

    uint256 public totalMinedSupply;
    uint256 public constant MINING_REWARD_HALVING_INTERVAL = 100_000_000 * 10**18;

    mapping(address => uint256) private lastRewardClaim;

    struct Allocation {
    uint256 amount;
    uint256 claimed;
    uint256 lastClaim;
}

uint256 public constant MAX_SUPPLY = 1_000_000_000 * 10**18;
uint256 public constant INITIAL_LOCK_PERIOD = 365 days;
uint256 public constant QUARTER = 91 days;

mapping(address => Allocation) public teamAdvisorAllocations;

uint256 public deploymentTime;

    event RewardClaimed(address indexed user, uint256 amount);

    constructor(
    address _wsgbTokenAddress,
    address _developmentFund,
    address _liquidityPool,
    address[] memory teamAdvisors,
    uint256[] memory _teamAdvisorAllocationAmounts
) ERC20("BlueBird Token", "Btst") {
    wsgbToken = IERC20(_wsgbTokenAddress);
    developmentFund = _developmentFund;
    liquidityPool = _liquidityPool;
    miningRate = 50;
    deploymentTime = block.timestamp;

    // Mint tokens for the liquidity pool and development fund
    uint256 liquidityPoolTokens = MAX_SUPPLY * liquidityPoolRate / 10000;
    uint256 developmentFundTokens = MAX_SUPPLY * developmentFundRate / 10000;
    _mint(liquidityPool, liquidityPoolTokens);
    _mint(developmentFund, developmentFundTokens);

    // Check if input arrays have the same length
    require(teamAdvisors.length == _teamAdvisorAllocationAmounts.length, "Input array lengths must match");

    // Assign allocations to team and advisors and mint tokens
    for (uint256 i = 0; i < teamAdvisors.length; i++) {
        Allocation memory allocation;
        allocation.amount = _teamAdvisorAllocationAmounts[i];
        allocation.claimed = 0;
        allocation.lastClaim = block.timestamp + INITIAL_LOCK_PERIOD;
        teamAdvisorAllocations[teamAdvisors[i]] = allocation;

        // Mint tokens for the team advisors
        _mint(teamAdvisors[i], _teamAdvisorAllocationAmounts[i]);
    }
}


modifier enforceMaxSupply(uint256 amount) {
    require(totalSupply() + amount <= MAX_SUPPLY, "Exceeds maximum supply");
    _;
}

function _mint(address account, uint256 amount) internal virtual override enforceMaxSupply(amount) {
    super._mint(account, amount);
}


    function mine(uint256 wsgbAmount, address recipient) external {
        require(wsgbAmount > 0, "Mine: WSGb amount should be greater than 0");
        require(recipient != address(0), "Mine: Recipient address cannot be 0x0");

        uint256 brdReward = wsgbAmount * currentMiningRate / 100;

        wsgbToken.transferFrom(msg.sender, recipient, wsgbAmount);
        _mint(msg.sender, brdReward);
        totalMinedSupply += brdReward;

        _updateMiningRewardRate();
    }

    function _updateMiningRewardRate() private {
        if (totalMinedSupply >= MINING_REWARD_HALVING_INTERVAL) {
            currentMiningRate /= 2;
            totalMinedSupply = 0;
        }
    }


    function claimReward() external {
        uint256 currentTime = block.timestamp;
        uint256 timeSinceLastClaim = currentTime - lastRewardClaim[msg.sender];

        require(timeSinceLastClaim >= 1 days, "Claim: At least 24 hours must pass between claims");

        uint256 reward = balanceOf(msg.sender) * 1 / 100;
        lastRewardClaim[msg.sender] = currentTime;

        _mint(msg.sender, reward);
        emit RewardClaimed(msg.sender, reward);
    }

    function claimTeamAdvisorAllocation() external {
    require(block.timestamp >= deploymentTime + INITIAL_LOCK_PERIOD, "Tokens are still locked");
    Allocation storage allocation = teamAdvisorAllocations[msg.sender];
    require(allocation.amount > 0, "No allocation found");

    uint256 quartersPassed = (block.timestamp - allocation.lastClaim) / QUARTER;
    require(quartersPassed > 0, "Already claimed for this quarter");

    uint256 claimable = allocation.amount * 25 / 100 * quartersPassed;
    uint256 remainingClaimable = allocation.amount - allocation.claimed;
    uint256 actualClaim = claimable < remainingClaimable ? claimable : remainingClaimable;

    require(actualClaim > 0, "Nothing left to claim");

    allocation.claimed += actualClaim;
    allocation.lastClaim = block.timestamp;

    _mint(msg.sender, actualClaim);
}

}

